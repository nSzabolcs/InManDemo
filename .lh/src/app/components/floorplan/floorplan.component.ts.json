{
    "sourceFile": "src/app/components/floorplan/floorplan.component.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 6,
            "patches": [
                {
                    "date": 1753090460173,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1753090628624,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -586,9 +586,9 @@\n     const activeObj = this.canvas.getActiveObject();\n     if (activeObj)\n     console.log('Kijelölt objektum:', activeObj.type);\n     \n-   if (activeObj instanceof fabric.Textbox || activeObj?.constructor?.name === 'Textbox') {\n+if (activeObj?.type === 'textbox') {\n   this.selectedTextObject = activeObj as fabric.Textbox;\n \n   this.formTextStyle.fill = this.selectedTextObject.fill as string;\n   this.formTextStyle.fontSize = this.selectedTextObject.fontSize ?? 20;\n@@ -602,8 +602,9 @@\n   this.selectedTextObject = null;\n }\n \n \n+\n     if (activeObj && activeObj.type === 'line') {\n       this.selectedLineObject = activeObj as fabric.Line;\n       this.formLineStyle.stroke = this.parseColorToHex(this.selectedLineObject.stroke as string);\n       this.formLineStyle.strokeWidth = this.selectedLineObject.strokeWidth ?? 2;\n"
                },
                {
                    "date": 1753091393466,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -586,25 +586,25 @@\n     const activeObj = this.canvas.getActiveObject();\n     if (activeObj)\n     console.log('Kijelölt objektum:', activeObj.type);\n     \n-if (activeObj?.type === 'textbox') {\n-  this.selectedTextObject = activeObj as fabric.Textbox;\n+    if (activeObj && activeObj.type === 'text') {\n+      this.selectedTextObject = activeObj as fabric.Textbox;\n \n-  this.formTextStyle.fill = this.selectedTextObject.fill as string;\n-  this.formTextStyle.fontSize = this.selectedTextObject.fontSize ?? 20;\n-  this.formTextStyle.fontFamily = this.selectedTextObject.fontFamily ?? 'Arial';\n-  this.formTextStyle.fontWeight = this.selectedTextObject.fontWeight === 'bold' ? 'bold' : 'normal';\n-  this.formTextStyle.fontStyle = this.selectedTextObject.fontStyle === 'italic' ? 'italic' : 'normal';\n-  this.formTextStyle.underline = this.selectedTextObject.underline ?? false;\n-  this.formTextStyle.linethrough = this.selectedTextObject.linethrough ?? false;\n-  this.formTextStyle.textAlign = (this.selectedTextObject.textAlign ?? 'left') as 'left' | 'center' | 'right';\n-} else {\n-  this.selectedTextObject = null;\n-}\n+      // Szinkronizálás a formTextStyle-lal\n+      this.formTextStyle.fill = this.selectedTextObject.fill as string;\n+      this.formTextStyle.fontSize = this.selectedTextObject.fontSize ?? 20;\n+      this.formTextStyle.fontFamily = this.selectedTextObject.fontFamily ?? 'Arial';\n+      this.formTextStyle.fontWeight = this.selectedTextObject.fontWeight === 'bold' ? 'bold' : 'normal';\n+      this.formTextStyle.fontStyle = this.selectedTextObject.fontStyle === 'italic' ? 'italic' : 'normal';\n+      this.formTextStyle.underline = this.selectedTextObject.underline ?? false;\n+      this.formTextStyle.linethrough = this.selectedTextObject.linethrough ?? false;\n+      this.formTextStyle.textAlign = (this.selectedTextObject.textAlign ?? 'left') as 'left' | 'center' | 'right';\n \n+    } else {\n+      this.selectedTextObject = null;\n+    }\n \n-\n     if (activeObj && activeObj.type === 'line') {\n       this.selectedLineObject = activeObj as fabric.Line;\n       this.formLineStyle.stroke = this.parseColorToHex(this.selectedLineObject.stroke as string);\n       this.formLineStyle.strokeWidth = this.selectedLineObject.strokeWidth ?? 2;\n"
                },
                {
                    "date": 1753091433102,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1175,12 +1175,13 @@\n \n   saveToDatabase(): void {\n \n \n-    const svg = this.canvas.toSVG();\n+   // const svg = this.canvas.toSVG();\n+    const json = this.canvas.toJSON();\n \n     const payload = {\n-      floorplan: svg\n+      floorplan: json\n     };\n \n     // Például HTTP PATCH vagy PUT metódus (backend implementációtól függően)\n     this.api.update('levels', this.levelId!, payload).subscribe({\n"
                },
                {
                    "date": 1753091590052,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -183,9 +183,8 @@\n     if (e.key === 'Shift') {\n       this.isShiftDown = false;\n     }\n \n-\n     if (e.key === 'Alt') {\n       this.canvas.setCursor('crosshair');\n       this.canvas.renderAll();\n     }\n@@ -198,9 +197,12 @@\n \n       this.api.select('levels', this.levelId).subscribe({\n         next: (res) => {\n           if (res.floorplan != null) {\n-            this.loadSvgFromText(res.floorplan);\n+           // this.loadSvgFromText(res.floorplan);\n+           this.canvas.loadFromJSON(res.floorplan, () => {\n+              this.canvas.renderAll();\n+            });\n           }\n         }\n       })\n     });\n"
                },
                {
                    "date": 1753091677662,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1177,9 +1177,9 @@\n \n   saveToDatabase(): void {\n \n    // const svg = this.canvas.toSVG();\n-    const json = this.canvas.toJSON();\n+    const json = JSON.stringify(this.canvas.toJSON());\n \n     const payload = {\n       floorplan: json\n     };\n"
                },
                {
                    "date": 1753091938645,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -208,8 +208,9 @@\n     });\n \n     window.addEventListener('keydown', this.handleKeyDown);\n     window.addEventListener('keyup', this.handleKeyUp);\n+    this.canvas.renderAll();\n   }\n \n   ngOnDestroy(): void {\n     window.removeEventListener('keydown', this.handleKeyDown);\n@@ -1212,10 +1213,8 @@\n       }\n \n       this.canvas.clear();\n       for (const obj of objects) {\n-\n-\n         this.canvas.add(obj);\n       }\n \n \n"
                }
            ],
            "date": 1753090460173,
            "name": "Commit-0",
            "content": "import { CommonModule } from '@angular/common';\nimport { AfterViewInit, Component, HostListener, inject, OnDestroy, OnInit } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { MatButtonModule } from '@angular/material/button';\nimport { MatButtonToggleModule } from '@angular/material/button-toggle';\nimport { MatCheckboxModule } from '@angular/material/checkbox';\nimport { MatIconModule } from '@angular/material/icon';\nimport { ActivatedRoute, RouterModule } from '@angular/router';\nimport { MatSelectModule } from '@angular/material/select';\nimport { MatFormFieldModule } from '@angular/material/form-field';\nimport { MatInputModule } from '@angular/material/input';\nimport { MatSliderModule } from '@angular/material/slider';\n\nimport * as fabric from 'fabric';\nimport { ApiService } from '../../services/api.service';\nimport { MatSnackBar } from '@angular/material/snack-bar';\n\n@Component({\n  selector: 'app-floorplan',\n  standalone: true,\n  imports: [MatButtonToggleModule, MatIconModule, MatButtonModule, RouterModule, FormsModule, MatCheckboxModule, CommonModule, MatSelectModule, MatFormFieldModule, MatInputModule, MatSliderModule],\n  templateUrl: './floorplan.component.html',\n  styleUrl: './floorplan.component.scss'\n})\n\nexport class FloorplanComponent implements AfterViewInit, OnInit, OnDestroy {\n\n  mode: 'select' | 'line' | 'rect' | 'polygon' | 'textbox' | 'ellipse' | 'polyline' = 'select';\n\n  levelId: any = null;\n  readonly route = inject(ActivatedRoute);\n  readonly snackBar = inject(MatSnackBar);\n  private isShiftDown = false;\n  gridSnapEnabled: boolean = false;\n\n  public canvas!: fabric.Canvas;\n  private points: { x: number, y: number }[] = [];\n  private pointCircles: fabric.Circle[] = [];\n  private lineCircles: fabric.Circle[] = [];\n  private lines: fabric.Line[] = [];\n  private radius = 5;\n  private previewLine: fabric.Line | null = null;\n\n  private rectStartPoint: { x: number, y: number } | null = null;\n  private rectPreview: fabric.Rect | null = null;\n  private ellipsePreview: fabric.Ellipse | null = null;\n\n  private lineStartPoint: { x: number, y: number } | null = null;\n  private linePreview: fabric.Line | null = null;\n\n  private isPanning = false;\n  private lastPanPoint: fabric.Point | null = null;\n\n  private gridSpacing = 50;\n\n  constructor(\n    private api: ApiService\n  ) { }\n\n  @HostListener('window:resize')\n  onResize() {\n    this.resizeCanvas();\n  }\n\n  formTextStyle = {\n    fill: '#000000',\n    fontSize: 20,\n    fontFamily: 'Arial',\n    fontWeight: 'normal' as 'normal' | 'bold',\n    fontStyle: 'normal' as 'normal' | 'italic',\n    textAlign: 'left' as 'left' | 'center' | 'right',\n    underline: false,\n    linethrough: false\n  };\n\n  formLineStyle = {\n    stroke: '#000000',\n    strokeWidth: 2,\n    strokeDashArray: 'solid'\n  };\n\n  formPolylineStyle = {\n    stroke: '#000000',\n    strokeWidth: 2,\n    strokeDashArray: 'solid'\n  };\n\n  formRectStyle = {\n    stroke: '#000000',\n    strokeWidth: 2,\n    strokeDashArray: 'solid',\n    fill: '#cccccc',\n    fillOpacity: 50,\n  };\n\n  formEllipseStyle = {\n    stroke: '#000000',\n    strokeWidth: 2,\n    strokeDashArray: 'solid',\n    fill: '#cccccc',\n    fillOpacity: 50\n  };\n\n  formPolygonStyle = {\n    fill: '#88ccff',\n    fillOpacity: 50,\n    stroke: '#000000',\n    strokeWidth: 2,\n    strokeDashArray: 'solid'\n  };\n\n\n  selectedLineObject: fabric.Line | null = null;\n  selectedTextObject: fabric.Textbox | null = null;\n  selectedPolylineObject: fabric.Polyline | null = null;\n  selectedRectObject: fabric.Rect | null = null;\n  selectedEllipseObject: fabric.Ellipse | null = null;\n  selectedPolygonObject: fabric.Polygon | null = null;\n\n  get showTextPanel(): boolean {\n    return this.mode === 'textbox' || !!this.selectedTextObject;\n  }\n\n  get showLinePanel(): boolean {\n    return this.mode === 'line' || !!this.selectedLineObject;\n  }\n\n  get showPolylinePanel(): boolean {\n    return this.mode === 'polyline' || !!this.selectedPolylineObject;\n  }\n\n  get showRectPanel(): boolean {\n    return this.mode === 'rect' || !!this.selectedRectObject;\n  }\n\n  get showEllipsePanel(): boolean {\n    return this.mode === 'ellipse' || !!this.selectedEllipseObject;\n  }\n\n  get showPolygonPanel(): boolean {\n    return this.mode === 'polygon' || !!this.selectedPolygonObject;\n  }\n\n  get isObjectSelected(): boolean {\n    return this.mode === 'select' && !!this.canvas?.getActiveObject();\n  }\n\n  resizeCanvas(): void {\n    const container = document.querySelector('.toolbar') as HTMLElement;\n    const details = document.querySelector('.details') as HTMLElement;\n\n    if (container && details) {\n      const totalWidth = container.clientWidth;\n      const canvasWidth = totalWidth - details.offsetWidth - 15;\n\n      this.canvas.setWidth(canvasWidth);\n      this.canvas.setHeight(650); // vagy dinamikusan is számolhatod\n      this.canvas.renderAll();\n    }\n  }\n\n  handleKeyDown = (e: KeyboardEvent) => {\n    if (e.key === 'Shift') {\n      this.isShiftDown = true;\n    }\n\n    if (e.key === 'Alt') {\n      this.canvas.setCursor('grabbing');\n      this.canvas.renderAll();\n    }\n\n    if ((e.key === 'Delete' || e.key === 'Backspace') && this.mode === 'select') {\n      const activeObjects = this.canvas.getActiveObjects();\n      if (activeObjects.length > 0) {\n        activeObjects.forEach(obj => this.canvas.remove(obj));\n        this.canvas.discardActiveObject(); // kijelölés megszüntetése\n        this.canvas.renderAll();\n      }\n    }\n  };\n\n  handleKeyUp = (e: KeyboardEvent) => {\n    if (e.key === 'Shift') {\n      this.isShiftDown = false;\n    }\n\n\n    if (e.key === 'Alt') {\n      this.canvas.setCursor('crosshair');\n      this.canvas.renderAll();\n    }\n\n  };\n\n  ngOnInit(): void {\n    this.route.paramMap.subscribe(params => {\n      this.levelId = params.get('id');\n\n      this.api.select('levels', this.levelId).subscribe({\n        next: (res) => {\n          if (res.floorplan != null) {\n            this.loadSvgFromText(res.floorplan);\n          }\n        }\n      })\n    });\n\n    window.addEventListener('keydown', this.handleKeyDown);\n    window.addEventListener('keyup', this.handleKeyUp);\n  }\n\n  ngOnDestroy(): void {\n    window.removeEventListener('keydown', this.handleKeyDown);\n    window.removeEventListener('keyup', this.handleKeyUp);\n  }\n\n  ngAfterViewInit(): void {\n    this.canvas = new fabric.Canvas('canvas-id', {\n      selection: false,\n      preserveObjectStacking: true,\n      defaultCursor: 'crosshair'\n    });\n\n    this.resizeCanvas();\n\n    this.canvas.on('before:render', () => {\n      this.drawInfiniteGrid();\n    });\n\n    this.canvas.on('mouse:down', (event) => {\n\n      const evt = event.e as MouseEvent;\n\n      if (evt.altKey && evt.button === 0) {  // Középső egérgomb\n        this.isPanning = true;\n        this.lastPanPoint = new fabric.Point(evt.clientX, evt.clientY);\n        evt.preventDefault();\n        return;\n      }\n\n      const pointer = this.getSnappedPointer(this.canvas.getPointer(event.e));\n\n      // --- SELECT ---\n      if (this.mode === 'select') return;\n\n      // --- LINE ---\n      if (this.mode === 'line') {\n        if (!this.lineStartPoint) {\n          // első kattintás: kezdőpont mentése\n          this.lineStartPoint = pointer;\n\n          // kis zöld kör az első ponthoz\n          const circle = new fabric.Circle({\n            left: pointer.x,\n            top: pointer.y,\n            radius: this.radius,\n            fill: 'red',\n            selectable: false,\n            originX: 'center',\n            originY: 'center'\n          });\n          this.lineCircles.push(circle);\n          this.canvas.add(circle);\n        } else {\n          // második kattintás: végleges vonal\n          const line = new fabric.Line(\n            [this.lineStartPoint.x, this.lineStartPoint.y, pointer.x, pointer.y],\n            {\n              stroke: this.formLineStyle.stroke,\n              strokeWidth: this.formLineStyle.strokeWidth,\n              strokeDashArray: this.formLineStyle.strokeDashArray === 'solid' ? [0, 0] :\n                this.formLineStyle.strokeDashArray === 'dashed' ? [5, 5] :\n                  [2, 2]\n            }\n          );\n          this.canvas.add(line);\n\n          // kis zöld kör a második ponthoz\n          const circle = new fabric.Circle({\n            left: pointer.x,\n            top: pointer.y,\n            radius: this.radius,\n            fill: 'red',\n            selectable: false,\n            originX: 'center',\n            originY: 'center'\n          });\n          this.lineCircles.push(circle);\n          this.canvas.add(circle);\n\n          // körök eltávolítása\n          this.lineCircles.forEach(c => this.canvas.remove(c));\n          this.lineCircles = [];\n\n          this.lineStartPoint = null;\n\n          if (this.linePreview) {\n            this.canvas.remove(this.linePreview);\n            this.linePreview = null;\n          }\n        }\n        return;\n      }\n\n      // --- POLYLINE ---\n      if (this.mode === 'polyline') {\n        this.handlePolylineMouseDown(pointer);\n        return;\n      }\n\n      // --- RECTANGLE ---\n      if (this.mode === 'rect') {\n        if (!this.rectStartPoint) {\n          // első kattintás: kezdőpont mentése\n          this.rectStartPoint = pointer;\n        } else {\n          const alpha = this.formRectStyle.fillOpacity / 100;\n          const rgbaFill = this.hexToRgba(this.formRectStyle.fill, alpha);\n          // második kattintás: végleges téglalap\n          const rect = this.createRectFromPoints(this.rectStartPoint, pointer, {\n            fill: rgbaFill,\n            stroke: this.formRectStyle.stroke,\n            strokeWidth: this.formRectStyle.strokeWidth,\n            strokeDashArray: this.formRectStyle.strokeDashArray === 'solid' ? [] :\n              this.formRectStyle.strokeDashArray === 'dashed' ? [5, 5] : [2, 2]\n          });\n          this.canvas.add(rect);\n          this.rectStartPoint = null;\n\n          if (this.rectPreview) {\n            this.canvas.remove(this.rectPreview);\n            this.rectPreview = null;\n          }\n        }\n        return;\n      }\n\n      // --- POLYGON ---\n      if (this.mode === 'polygon') {\n        this.handlePolygonMouseDown(pointer);\n        return\n      }\n\n      // --- ELLIPSE ---\n      if (this.mode === 'ellipse') {\n        if (!this.rectStartPoint) {\n          this.rectStartPoint = pointer;\n        } else {\n          let rx = Math.abs(pointer.x - this.rectStartPoint.x) / 2;\n          let ry = Math.abs(pointer.y - this.rectStartPoint.y) / 2;\n\n          // SHIFT: kör\n          if (this.isShiftDown) {\n            const r = Math.min(rx, ry);\n            rx = ry = r;\n          }\n\n          const cx = (pointer.x + this.rectStartPoint.x) / 2;\n          const cy = (pointer.y + this.rectStartPoint.y) / 2;\n\n          const alpha = this.formEllipseStyle.fillOpacity / 100;\n          const rgbaFill = this.hexToRgba(this.formEllipseStyle.fill, alpha);\n\n          const ellipse = new fabric.Ellipse({\n            left: cx - rx,\n            top: cy - ry,\n            originX: 'left',\n            originY: 'top',\n            rx,\n            ry,\n            fill: rgbaFill,\n            stroke: this.formEllipseStyle.stroke,\n            strokeWidth: this.formEllipseStyle.strokeWidth,\n            strokeDashArray:\n              this.formEllipseStyle.strokeDashArray === 'solid' ? [] :\n                this.formEllipseStyle.strokeDashArray === 'dashed' ? [5, 5] :\n                  [2, 2]\n          });\n\n\n          this.canvas.add(ellipse);\n          this.rectStartPoint = null;\n\n          if (this.ellipsePreview) {\n            this.canvas.remove(this.ellipsePreview);\n            this.ellipsePreview = null;\n          }\n        }\n        return;\n      }\n\n      // --- TEXT ---\n      if (this.mode === 'textbox') {\n        const textbox = new fabric.Textbox('Szöveg', {\n          left: pointer.x,\n          top: pointer.y,\n          fontSize: this.formTextStyle.fontSize,\n          fill: this.formTextStyle.fill,\n          fontFamily: this.formTextStyle.fontFamily,\n          fontWeight: this.formTextStyle.fontWeight,\n          fontStyle: this.formTextStyle.fontStyle,\n          underline: this.formTextStyle.underline,\n          linethrough: this.formTextStyle.linethrough,\n          editable: true,\n          textAlign: this.formTextStyle.textAlign,\n          originX: this.formTextStyle.textAlign,\n          originY: 'top'\n        });\n\n        this.canvas.add(textbox);\n        this.canvas.setActiveObject(textbox);\n        this.canvas.renderAll();\n\n        return;\n      }\n\n    });\n\n    this.canvas.on('mouse:move', (event) => {\n      const evt = event.e as MouseEvent;\n\n      // --- CURSOR ---\n      if (evt.altKey) {\n        this.canvas.upperCanvasEl.style.cursor = 'grabbing';\n      } else {\n        this.canvas.upperCanvasEl.style.cursor = this.mode === 'select' ? 'default' : 'crosshair';\n      }\n\n      // --- PANNING ---\n      if (this.isPanning && this.lastPanPoint) {\n        const newPoint = new fabric.Point(evt.clientX, evt.clientY);\n        const delta = newPoint.subtract(this.lastPanPoint);\n\n        this.canvas.relativePan(delta);\n        this.lastPanPoint = newPoint;\n\n        evt.preventDefault();\n        return;\n      }\n\n      const rawPointer = this.canvas.getPointer(event.e);\n      const pointer = this.getSnappedPointer(rawPointer);\n\n      // --- LINE ---\n      if (this.mode === 'line' && this.lineStartPoint) {\n        if (this.linePreview) {\n          this.linePreview.set({ x2: pointer.x, y2: pointer.y });\n        } else {\n          this.linePreview = new fabric.Line(\n            [this.lineStartPoint.x, this.lineStartPoint.y, pointer.x, pointer.y],\n            {\n              stroke: 'gray',\n              strokeDashArray: [5, 5],\n              strokeWidth: 1,\n              selectable: false,\n              evented: false\n            }\n          );\n          this.canvas.add(this.linePreview);\n        }\n        this.canvas.renderAll();\n        return;\n      }\n\n      // --- RECTANGLE ---\n      if (this.mode === 'rect' && this.rectStartPoint) {\n        const rectData = this.getRectDimensions(this.rectStartPoint, pointer);\n        if (this.rectPreview) {\n          this.rectPreview.set(rectData);\n        } else {\n          this.rectPreview = new fabric.Rect({\n            ...rectData,\n            stroke: 'gray',\n            strokeDashArray: [5, 5],\n            fill: 'rgba(0,0,0,0)',\n            selectable: false,\n            evented: false\n          });\n          this.canvas.add(this.rectPreview);\n        }\n        this.canvas.renderAll();\n        return;\n      }\n\n      // --- ELLIPSE ---\n      if (this.mode === 'ellipse' && this.rectStartPoint) {\n        const p1 = this.rectStartPoint;\n        const p2 = rawPointer;\n\n        let rx = Math.abs(p2.x - p1.x) / 2;\n        let ry = Math.abs(p2.y - p1.y) / 2;\n\n        if (this.isShiftDown) {\n          const r = Math.min(rx, ry);\n          rx = ry = r;\n        }\n\n        const cx = (p1.x + p2.x) / 2;\n        const cy = (p1.y + p2.y) / 2;\n\n        if (this.ellipsePreview) {\n          this.ellipsePreview.set({ left: cx - rx, top: cy - ry, rx, ry });\n        } else {\n          this.ellipsePreview = new fabric.Ellipse({\n            left: cx - rx,\n            top: cy - ry,\n            originX: 'left',\n            originY: 'top',\n            rx,\n            ry,\n            fill: 'rgba(0,0,0,0)',\n            stroke: 'gray',\n            strokeDashArray: [5, 5],\n            strokeWidth: 1,\n            selectable: false,\n            evented: false\n          });\n          this.canvas.add(this.ellipsePreview);\n        }\n        this.canvas.renderAll();\n        return;\n      }\n\n      // --- POLYGON és POLYLINE ---\n      if ((this.mode === 'polygon' || this.mode === 'polyline') && this.points.length > 0) {\n        const lastPoint = this.points[this.points.length - 1];\n\n        if (this.previewLine) {\n          this.previewLine.set({ x2: pointer.x, y2: pointer.y });\n          this.canvas.renderAll();\n        } else {\n          this.previewLine = new fabric.Line(\n            [lastPoint.x, lastPoint.y, pointer.x, pointer.y],\n            {\n              stroke: 'gray',\n              strokeDashArray: [5, 5],\n              strokeWidth: 1,\n              selectable: false,\n              evented: false\n            }\n          );\n          this.canvas.add(this.previewLine);\n        }\n      }\n    });\n\n    this.canvas.on('mouse:wheel', (opt) => {\n      const delta = opt.e.deltaY;\n      let zoom = this.canvas.getZoom();\n\n      // Skála változtatása\n      zoom *= 0.999 ** delta;\n\n      // Zoom korlátok\n      zoom = Math.max(0.2, Math.min(zoom, 5));\n\n      const pointer = this.canvas.getPointer(opt.e);\n\n      const point = new fabric.Point(opt.e.offsetX, opt.e.offsetY);\n      this.canvas.zoomToPoint(point, zoom);\n      opt.e.preventDefault();\n      opt.e.stopPropagation();\n    });\n\n    this.canvas.on('mouse:up', () => {\n      this.isPanning = false;\n      this.lastPanPoint = null;\n    });\n\n    this.canvas.on('selection:created', (e) => this.onSelectionChanged(e));\n    this.canvas.on('selection:updated', (e) => this.onSelectionChanged(e));\n    this.canvas.on('selection:cleared', () => {\n      this.selectedTextObject = null;\n      this.selectedLineObject = null;\n      this.selectedPolylineObject = null;\n      this.selectedRectObject = null;\n      this.selectedEllipseObject = null;\n      this.selectedPolygonObject = null;\n    });\n\n    this.drawInfiniteGrid();\n\n  }\n\n  private onSelectionChanged(e: Partial<fabric.TEvent<fabric.TPointerEvent>>) {\n    const activeObj = this.canvas.getActiveObject();\n    if (activeObj)\n    console.log('Kijelölt objektum:', activeObj.type);\n    \n   if (activeObj instanceof fabric.Textbox || activeObj?.constructor?.name === 'Textbox') {\n  this.selectedTextObject = activeObj as fabric.Textbox;\n\n  this.formTextStyle.fill = this.selectedTextObject.fill as string;\n  this.formTextStyle.fontSize = this.selectedTextObject.fontSize ?? 20;\n  this.formTextStyle.fontFamily = this.selectedTextObject.fontFamily ?? 'Arial';\n  this.formTextStyle.fontWeight = this.selectedTextObject.fontWeight === 'bold' ? 'bold' : 'normal';\n  this.formTextStyle.fontStyle = this.selectedTextObject.fontStyle === 'italic' ? 'italic' : 'normal';\n  this.formTextStyle.underline = this.selectedTextObject.underline ?? false;\n  this.formTextStyle.linethrough = this.selectedTextObject.linethrough ?? false;\n  this.formTextStyle.textAlign = (this.selectedTextObject.textAlign ?? 'left') as 'left' | 'center' | 'right';\n} else {\n  this.selectedTextObject = null;\n}\n\n\n    if (activeObj && activeObj.type === 'line') {\n      this.selectedLineObject = activeObj as fabric.Line;\n      this.formLineStyle.stroke = this.parseColorToHex(this.selectedLineObject.stroke as string);\n      this.formLineStyle.strokeWidth = this.selectedLineObject.strokeWidth ?? 2;\n\n      const dashArray = this.selectedLineObject.strokeDashArray;\n      console.log(dashArray)\n      if (!dashArray || dashArray.length === 0) {\n        this.formLineStyle.strokeDashArray = 'solid';\n      }else if (dashArray[0] === 0 && dashArray[1] === 0) {\n        this.formLineStyle.strokeDashArray = 'solid';\n      } else if (dashArray[0] === 5 && dashArray[1] === 5) {\n        this.formLineStyle.strokeDashArray = 'dashed';\n      } else if (dashArray[0] === 2 && dashArray[1] === 2) {\n        this.formLineStyle.strokeDashArray = 'dotted';\n      }\n    } else {\n      this.selectedLineObject = null;\n    }\n\n    if (activeObj && activeObj.type === 'polyline') {\n      this.selectedPolylineObject = activeObj as fabric.Polyline;\n\n      this.formPolylineStyle.stroke = this.parseColorToHex(this.selectedPolylineObject.stroke as string);\n      this.formPolylineStyle.strokeWidth = this.selectedPolylineObject.strokeWidth ?? 2;\n\n      const dashArray = this.selectedPolylineObject.strokeDashArray;\n      if (!dashArray || dashArray.length === 0) {\n        this.formPolylineStyle.strokeDashArray = 'solid';\n      } else if (dashArray[0] === 0 && dashArray[1] === 0) {\n        this.formPolylineStyle.strokeDashArray = 'solid';\n      } else if (dashArray[0] === 5 && dashArray[1] === 5) {\n        this.formPolylineStyle.strokeDashArray = 'dashed';\n      } else if (dashArray[0] === 2 && dashArray[1] === 2) {\n        this.formPolylineStyle.strokeDashArray = 'dotted';\n      }\n    } else {\n      this.selectedPolylineObject = null;\n    }\n\n    if (activeObj && activeObj.type === 'rect') {\n      this.selectedRectObject = activeObj as fabric.Rect;\n      this.formRectStyle.stroke = this.parseColorToHex(this.selectedRectObject.stroke as string);\n      //this.formRectStyle.stroke = this.selectedRectObject.stroke as string || '#000000';\n      this.formRectStyle.strokeWidth = this.selectedRectObject.strokeWidth ?? 2;\n\n      // --- Kitöltés szín és átlátszóság szétbontása ---\n      const fill = this.selectedRectObject.fill;\n\n      const { hex, opacity } = this.extractFillAndOpacity(fill as string);\n      this.formRectStyle.fill = hex as string;\n      this.formRectStyle.fillOpacity = opacity;\n\n      const dashArray = this.selectedRectObject.strokeDashArray;\n      if (!dashArray || dashArray.length === 0 ) {\n        this.formRectStyle.strokeDashArray = 'solid';\n      } else if (dashArray[0] === 5 && dashArray[1] === 5) {\n        this.formRectStyle.strokeDashArray = 'dashed';\n      } else if (dashArray[0] === 2 && dashArray[1] === 2) {\n        this.formRectStyle.strokeDashArray = 'dotted';\n      } else {\n       this.formRectStyle.strokeDashArray = 'solid'; \n      }\n\n    } else {\n      this.selectedRectObject = null;\n    }\n\n    if (activeObj && activeObj.type === 'ellipse') {\n      this.selectedEllipseObject = activeObj as fabric.Ellipse;\n\n      this.formEllipseStyle.stroke = this.parseColorToHex(this.selectedEllipseObject.stroke as string);\n      this.formEllipseStyle.strokeWidth = this.selectedEllipseObject.strokeWidth ?? 2;\n\n      const fill = this.selectedEllipseObject.fill;\n      const { hex, opacity } = this.extractFillAndOpacity(fill as string);\n      this.formEllipseStyle.fill = hex as string;\n      this.formEllipseStyle.fillOpacity = opacity;\n      \n      const dashArray = this.selectedEllipseObject.strokeDashArray;\n      if (!dashArray || dashArray.length === 0) {\n        this.formEllipseStyle.strokeDashArray = 'solid';\n      } else if (dashArray[0] === 5 && dashArray[1] === 5) {\n        this.formEllipseStyle.strokeDashArray = 'dashed';\n      } else if (dashArray[0] === 2 && dashArray[1] === 2) {\n        this.formEllipseStyle.strokeDashArray = 'dotted';\n      } else {\n        this.formEllipseStyle.strokeDashArray = 'solid';\n      }\n    } else {\n      this.selectedEllipseObject = null;\n    }\n\n    if (activeObj && activeObj.type === 'polygon') {\n      this.selectedPolygonObject = activeObj as fabric.Polygon;\n\n      const fill = this.selectedPolygonObject.fill;\n      const { hex, opacity } = this.extractFillAndOpacity(fill as string);\n      this.formPolygonStyle.fill = hex as string;\n      this.formPolygonStyle.fillOpacity = opacity;\n  \n      this.formPolygonStyle.stroke = this.parseColorToHex(this.selectedPolygonObject.stroke as string);\n      this.formPolygonStyle.strokeWidth = this.selectedPolygonObject.strokeWidth ?? 2;\n\n      const dashArray = this.selectedPolygonObject.strokeDashArray;\n      if (!dashArray || dashArray.length === 0) {\n        this.formPolygonStyle.strokeDashArray = 'solid';\n      } else if (dashArray[0] === 5 && dashArray[1] === 5) {\n        this.formPolygonStyle.strokeDashArray = 'dashed';\n      } else if (dashArray[0] === 2 && dashArray[1] === 2) {\n        this.formPolygonStyle.strokeDashArray = 'dotted';\n      }\n    } else {\n      this.selectedPolygonObject = null;\n    }\n\n  }\n\n  private parseColorToHex(color: string | undefined | null): string {\n  if (!color) return '#000000';\n\n  if (color.startsWith('rgba') || color.startsWith('rgb')) {\n    const match = color.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)/);\n    if (match) {\n      const [_, r, g, b] = match;\n      return this.rgbToHex(parseInt(r), parseInt(g), parseInt(b));\n    }\n  }\n\n  return color; // ha már hex vagy érvényes CSS név\n}\n\nprivate extractFillAndOpacity(fill: string | undefined): { hex: string; opacity: number } {\n  if (!fill) return { hex: '#cccccc', opacity: 100 };\n\n  if (fill.startsWith('rgba')) {\n    const match = fill.match(/rgba\\((\\d+),\\s*(\\d+),\\s*(\\d+),\\s*([\\d.]+)\\)/);\n    if (match) {\n      const [_, r, g, b, a] = match;\n      return {\n        hex: this.rgbToHex(+r, +g, +b),\n        opacity: Math.round(+a * 100)\n      };\n    }\n  }\n\n  if (fill.startsWith('rgb')) {\n    const match = fill.match(/rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/);\n    if (match) {\n      const [_, r, g, b] = match;\n      return {\n        hex: this.rgbToHex(+r, +g, +b),\n        opacity: 100\n      };\n    }\n  }\n\n  return { hex: fill, opacity: 100 };\n}\n\n  applyTextStyle(): void {\n    if (this.selectedTextObject) {\n      this.selectedTextObject.set({\n        fill: this.formTextStyle.fill,\n        fontSize: this.formTextStyle.fontSize,\n        fontFamily: this.formTextStyle.fontFamily,\n        fontWeight: this.formTextStyle.fontWeight,\n        fontStyle: this.formTextStyle.fontStyle,\n        textAlign: this.formTextStyle.textAlign,\n        underline: this.formTextStyle.underline,\n        linethrough: this.formTextStyle.linethrough\n      });\n      this.selectedTextObject.setCoords();\n      this.canvas.renderAll();\n    }\n  }\n\n  applyLineStyle(): void {\n    if (this.selectedLineObject) {\n      this.selectedLineObject.set({\n        stroke: this.formLineStyle.stroke,\n        strokeWidth: this.formLineStyle.strokeWidth,\n        strokeDashArray: this.formLineStyle.strokeDashArray === 'solid' ? [] :\n          this.formLineStyle.strokeDashArray === 'dashed' ? [5, 5] :\n            [2, 2]\n      });\n      this.canvas.renderAll();\n    }\n  }\n\n  applyPolylineStyle(): void {\n    if (this.selectedPolylineObject) {\n      this.selectedPolylineObject.set({\n        stroke: this.formPolylineStyle.stroke,\n        strokeWidth: this.formPolylineStyle.strokeWidth,\n        strokeDashArray: this.formPolylineStyle.strokeDashArray === 'solid' ? [] :\n          this.formPolylineStyle.strokeDashArray === 'dashed' ? [5, 5] :\n            [2, 2]\n      });\n      this.canvas.renderAll();\n    }\n  }\n\n  applyRectStyle(): void {\n    if (this.selectedRectObject) {\n      const alpha = this.formRectStyle.fillOpacity / 100;\n      const rgbaFill = this.hexToRgba(this.formRectStyle.fill, alpha);\n      this.selectedRectObject.set({\n        fill: rgbaFill,\n        stroke: this.formRectStyle.stroke,\n        strokeWidth: this.formRectStyle.strokeWidth,\n        strokeDashArray:\n          this.formRectStyle.strokeDashArray === 'solid' ? [] :\n            this.formRectStyle.strokeDashArray === 'dashed' ? [5, 5] : [2, 2]\n      });\n\n      this.canvas.renderAll();\n    }\n  }\n\n  applyEllipseStyle(): void {\n    if (this.selectedEllipseObject) {\n      const alpha = this.formEllipseStyle.fillOpacity / 100;\n      const rgbaFill = this.hexToRgba(this.formEllipseStyle.fill, alpha);\n      this.selectedEllipseObject.set({\n        fill: rgbaFill,\n        stroke: this.formEllipseStyle.stroke,\n        strokeWidth: this.formEllipseStyle.strokeWidth,\n        strokeDashArray:\n          this.formEllipseStyle.strokeDashArray === 'solid' ? [] :\n            this.formEllipseStyle.strokeDashArray === 'dashed' ? [5, 5] : [2, 2]\n      });\n      this.canvas.renderAll();\n    }\n  }\n\n  applyPolygonStyle(): void {\n    if (this.selectedPolygonObject) {\n      const alpha = this.formPolygonStyle.fillOpacity / 100;\n      const rgbaFill = this.hexToRgba(this.formPolygonStyle.fill, alpha);\n\n      this.selectedPolygonObject.set({\n        fill: rgbaFill,\n        stroke: this.formPolygonStyle.stroke,\n        strokeWidth: this.formPolygonStyle.strokeWidth,\n        strokeDashArray:\n          this.formPolygonStyle.strokeDashArray === 'solid' ? [] :\n            this.formPolygonStyle.strokeDashArray === 'dashed' ? [5, 5] : [2, 2]\n      });\n\n      this.canvas.renderAll();\n    }\n  }\n\n  bringToFront() {\n    const active = this.canvas.getActiveObject();\n    if (active) {\n      this.canvas.remove(active);\n      this.canvas.add(active);\n      this.canvas.setActiveObject(active);\n      this.canvas.renderAll();\n    }\n  }\n\n  sendToBack() {\n    const active = this.canvas.getActiveObject();\n    if (active) {\n      this.canvas.remove(active);\n      this.canvas.insertAt(0, active);\n      this.canvas.setActiveObject(active);\n      this.canvas.renderAll();\n    }\n  }\n\n  bringForward() {\n    const active = this.canvas.getActiveObject();\n    if (active) {\n      const index = this.canvas.getObjects().indexOf(active);\n      this.canvas.remove(active);\n      this.canvas.insertAt(index + 1, active);\n      this.canvas.setActiveObject(active);\n      this.canvas.renderAll();\n    }\n  }\n\n  sendBackward() {\n    const active = this.canvas.getActiveObject();\n    if (active) {\n      const index = this.canvas.getObjects().indexOf(active);\n      this.canvas.remove(active);\n      this.canvas.insertAt(index - 1, active);\n      this.canvas.setActiveObject(active);\n      this.canvas.renderAll();\n    }\n  }\n\n  hexToRgba(hex: string, alpha: number): string {\n    const bigint = parseInt(hex.replace('#', ''), 16);\n    const r = (bigint >> 16) & 255;\n    const g = (bigint >> 8) & 255;\n    const b = bigint & 255;\n    return `rgba(${r}, ${g}, ${b}, ${alpha})`;\n  }\n\n  rgbToHex(r: number, g: number, b: number): string {\n    return (\n      '#' +\n      [r, g, b]\n        .map((x) => {\n          const hex = x.toString(16);\n          return hex.length === 1 ? '0' + hex : hex;\n        })\n        .join('')\n    );\n  }\n\n  ngOnChanges(): void {\n    this.updateCanvasSelectability();\n  }\n\n  private updateCanvasSelectability(): void {\n    const isSelectable = this.mode === 'select';\n    this.canvas.selection = isSelectable;\n\n    this.canvas.forEachObject(obj => {\n      if ((obj as any).isGridLine) return; // rácsot kihagyjuk\n      obj.selectable = isSelectable;\n    });\n  }\n\n  private drawInfiniteGrid(): void {\n    const ctx = this.canvas.getContext();\n    const zoom = this.canvas.getZoom();\n    const vpt = this.canvas.viewportTransform;\n\n    if (!ctx || !vpt) return;\n\n    const spacing = this.gridSpacing * zoom;\n    const width = this.canvas.getWidth();\n    const height = this.canvas.getHeight();\n\n    const xOffset = vpt[4] % spacing;\n    const yOffset = vpt[5] % spacing;\n\n    ctx.save();\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = '#eee';\n\n    for (let x = xOffset; x <= width; x += spacing) {\n      ctx.beginPath();\n      ctx.moveTo(x, 0);\n      ctx.lineTo(x, height);\n      ctx.stroke();\n    }\n\n    for (let y = yOffset; y <= height; y += spacing) {\n      ctx.beginPath();\n      ctx.moveTo(0, y);\n      ctx.lineTo(width, y);\n      ctx.stroke();\n    }\n\n    ctx.restore();\n  }\n\n  onModeChange(): void {\n    const isSelectable = this.mode === 'select';\n    this.canvas.selection = isSelectable;\n\n    // Minden objektum kijelölhetőségének frissítése\n    this.canvas.forEachObject(obj => {\n      if ((obj as any).isGridLine) return;\n      obj.selectable = isSelectable;\n    });\n\n    // Kijelölések törlése módváltáskor\n    this.canvas.discardActiveObject();\n    this.selectedTextObject = null;\n    this.selectedLineObject = null;\n    this.selectedPolylineObject = null;\n    this.selectedRectObject = null;\n    this.selectedEllipseObject = null;\n    this.selectedPolygonObject = null;\n\n    this.canvas.renderAll();\n\n    // Kurzor frissítése\n    this.canvas.upperCanvasEl.style.cursor = this.mode === 'select' ? 'default' : 'crosshair';\n\n  }\n\n  private handlePolygonMouseDown(pointer: { x: number, y: number }) {\n    const clickedPointIndex = this.pointCircles.findIndex(circle =>\n      this.isPointNear(pointer, circle.left!, circle.top!, this.radius + 3)\n    );\n\n    if (clickedPointIndex === 0 && this.points.length >= 3) {\n      this.finishPolygon();\n      return;\n    }\n\n    const newPoint = { x: pointer.x, y: pointer.y };\n    this.points.push(newPoint);\n\n    const circle = new fabric.Circle({\n      left: newPoint.x,\n      top: newPoint.y,\n      radius: this.radius,\n      fill: 'red',\n      selectable: false,\n      originX: 'center',\n      originY: 'center'\n    });\n    this.pointCircles.push(circle);\n    this.canvas.add(circle);\n\n    if (this.points.length > 1) {\n      const prev = this.points[this.points.length - 2];\n      const line = new fabric.Line([prev.x, prev.y, newPoint.x, newPoint.y], {\n        stroke: this.formPolygonStyle.stroke,\n        strokeWidth: this.formPolygonStyle.strokeWidth,\n        strokeDashArray: this.formPolygonStyle.strokeDashArray === 'solid' ? [] : this.formPolygonStyle.strokeDashArray === 'dashed' ? [5, 5] : [2, 2],\n        selectable: false\n      });\n      this.lines.push(line);\n      this.canvas.add(line);\n    }\n\n    if (this.previewLine) {\n      this.canvas.remove(this.previewLine);\n      this.previewLine = null;\n    }\n  }\n\n  private handlePolylineMouseDown(rawPointer: { x: number, y: number }) {\n    const pointer = this.getSnappedPointer(rawPointer);\n\n    if (this.points.length > 0) {\n      const last = this.points[this.points.length - 1];\n      const dx = pointer.x - last.x;\n      const dy = pointer.y - last.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance < 5 && this.points.length >= 2) {\n        // ugyanoda kattintottunk vissza → lezárás\n        const polyline = new fabric.Polyline(this.points, {\n          fill: '',\n          stroke: this.formPolylineStyle.stroke,\n          strokeWidth: this.formPolylineStyle.strokeWidth,\n          strokeDashArray: this.formPolylineStyle.strokeDashArray === 'solid' ? [0, 0] : this.formPolylineStyle.strokeDashArray === 'dashed' ? [5, 5] : [2, 2],\n          selectable: true\n        });\n\n        this.canvas.add(polyline);\n\n        this.pointCircles.forEach(c => this.canvas.remove(c));\n        this.lines.forEach(l => this.canvas.remove(l));\n        this.canvas.renderAll();\n\n        this.points = [];\n        this.pointCircles = [];\n        this.lines = [];\n        this.previewLine = null;\n        return;\n      }\n    }\n\n    // új pont hozzáadása\n    const newPoint = { x: pointer.x, y: pointer.y };\n    this.points.push(newPoint);\n\n    const circle = new fabric.Circle({\n      left: newPoint.x,\n      top: newPoint.y,\n      radius: this.radius,\n      fill: 'red',\n      selectable: false,\n      originX: 'center',\n      originY: 'center'\n    });\n    this.pointCircles.push(circle);\n    this.canvas.add(circle);\n\n    if (this.points.length > 1) {\n      const prev = this.points[this.points.length - 2];\n      const line = new fabric.Line([prev.x, prev.y, newPoint.x, newPoint.y], {\n        stroke: this.formPolylineStyle.stroke,\n        strokeWidth: this.formPolylineStyle.strokeWidth,\n        strokeDashArray: this.formPolylineStyle.strokeDashArray === 'solid' ? [] : this.formPolylineStyle.strokeDashArray === 'dashed' ? [5, 5] : [2, 2],\n        selectable: false\n      });\n      this.lines.push(line);\n      this.canvas.add(line);\n    }\n\n    if (this.previewLine) {\n      this.canvas.remove(this.previewLine);\n      this.previewLine = null;\n    }\n  }\n\n  private isPointNear(p: { x: number, y: number }, x: number, y: number, threshold = 5): boolean {\n    const dx = p.x - x;\n    const dy = p.y - y;\n    return Math.sqrt(dx * dx + dy * dy) <= threshold;\n  }\n\n  private finishPolygon(): void {\n    const alpha = this.formPolygonStyle.fillOpacity / 100;\n    const rgbaFill = this.hexToRgba(this.formPolygonStyle.fill, alpha);\n\n    const polygon = new fabric.Polygon(this.points, {\n      fill: rgbaFill,\n      stroke: this.formPolygonStyle.stroke,\n      strokeWidth: this.formPolygonStyle.strokeWidth,\n      strokeDashArray: this.formPolygonStyle.strokeDashArray === 'solid' ? [] :\n        this.formPolygonStyle.strokeDashArray === 'dashed' ? [5, 5] : [2, 2],\n      selectable: true\n    });\n\n    this.canvas.add(polygon);\n\n    this.pointCircles.forEach(c => this.canvas.remove(c));\n    this.lines.forEach(l => this.canvas.remove(l));\n    this.canvas.renderAll();\n\n    this.points = [];\n    this.pointCircles = [];\n    this.lines = [];\n  }\n\n  private getSnappedPointer(pointer: { x: number; y: number }): { x: number; y: number } {\n    let refPoint: { x: number; y: number } | null = null;\n\n    if ((this.mode === 'polygon' || this.mode === 'polyline') && this.points.length > 0) {\n      refPoint = this.points[this.points.length - 1];\n    }\n\n    if (this.mode === 'line' && this.lineStartPoint) {\n      refPoint = this.lineStartPoint;\n    }\n\n    // Ha grid snap be van kapcsolva, kerekítsük a legközelebbi rácsvonalra\n    if (this.gridSnapEnabled) {\n      const spacing = this.gridSpacing;\n      const snappedX = Math.round(pointer.x / spacing) * spacing;\n      const snappedY = Math.round(pointer.y / spacing) * spacing;\n      return { x: snappedX, y: snappedY };\n    }\n\n    // Ha Shift le van nyomva és van ref pont, akkor irány szög snapping\n    if (this.isShiftDown && refPoint) {\n      const dx = pointer.x - refPoint.x;\n      const dy = pointer.y - refPoint.y;\n\n      const angle = Math.atan2(dy, dx);\n      const snapAngle = (Math.round(angle / (Math.PI / 4))) * (Math.PI / 4); // 8 irány\n\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      const snappedX = refPoint.x + Math.cos(snapAngle) * dist;\n      const snappedY = refPoint.y + Math.sin(snapAngle) * dist;\n\n      return { x: snappedX, y: snappedY };\n    }\n\n    // Alapértelmezett: nincs snap\n    return pointer;\n  }\n\n  saveToDatabase(): void {\n\n\n    const svg = this.canvas.toSVG();\n\n    const payload = {\n      floorplan: svg\n    };\n\n    // Például HTTP PATCH vagy PUT metódus (backend implementációtól függően)\n    this.api.update('levels', this.levelId!, payload).subscribe({\n      next: () => this.showSnackbar('Sikeres mentés!', 'success'),\n      error: err => this.showSnackbar('Hiba történt! ' + err.message, 'error')\n    });\n  }\n\n  downloadSvg(): void {\n    const svg = this.canvas.toSVG();\n    const blob = new Blob([svg], { type: 'image/svg+xml' });\n    const url = URL.createObjectURL(blob);\n\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = 'rajzolt.svg';\n    a.click();\n\n    URL.revokeObjectURL(url);\n  }\n\n  loadSvgFromText(svgText: string): void {\n    fabric.loadSVGFromString(svgText).then(({ objects }: any) => {\n      if (!objects || objects.length === 0) {\n        console.error('Nem sikerült betölteni SVG objektumokat');\n        return;\n      }\n\n      this.canvas.clear();\n      for (const obj of objects) {\n\n\n        this.canvas.add(obj);\n      }\n\n\n      this.canvas.renderAll();\n    });\n  }\n\n  onFileSelected(event: Event): void {\n    const input = event.target as HTMLInputElement;\n    if (!input.files?.length) return;\n\n    const file = input.files[0];\n    const reader = new FileReader();\n\n    reader.onload = () => {\n      const svgText = reader.result as string;\n      this.loadSvgFromText(svgText);\n    };\n\n    reader.readAsText(file);\n  }\n\n  clearCanvas(): void {\n    this.canvas.clear();\n\n    // Poligon állapot is nullázva legyen, ha félbehagyta:\n    this.points = [];\n    this.pointCircles = [];\n    this.lines = [];\n    this.previewLine = null;\n\n    // Visszaállítjuk az alap beállításokat (kijelölés módhoz például)\n    this.updateCanvasSelectability();\n\n    this.canvas.renderAll();\n  }\n\n  private getRectDimensions(p1: { x: number, y: number }, p2: { x: number, y: number }) {\n    const left = Math.min(p1.x, p2.x);\n    const top = Math.min(p1.y, p2.y);\n    const width = Math.abs(p2.x - p1.x);\n    const height = Math.abs(p2.y - p1.y);\n    return { left, top, width, height };\n  }\n\n  private createRectFromPoints(\n    p1: { x: number, y: number },\n    p2: { x: number, y: number },\n    options: {\n      fill?: string;\n      stroke?: string;\n      strokeWidth?: number;\n      opacity?: number;\n      strokeDashArray?: number[];\n    }\n  ): fabric.Rect {\n    const dims = this.getRectDimensions(p1, p2);\n    return new fabric.Rect({\n      ...dims,\n      ...options\n    });\n  }\n\n  resetView(): void {\n    this.canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);\n    this.canvas.setZoom(1);\n    this.canvas.renderAll();\n  }\n\n  onOpacityChange(event: Event): void {\n    const value = +(event.target as HTMLInputElement).value;\n    this.formRectStyle.fillOpacity = value;\n    this.applyRectStyle();\n  }\n\n  onEllipseOpacityChange(event: Event): void {\n    const value = +(event.target as HTMLInputElement).value;\n    this.formEllipseStyle.fillOpacity = value;\n    this.applyEllipseStyle();\n  }\n\n  onPolygonOpacityChange(event: Event): void {\n    const value = +(event.target as HTMLInputElement).value;\n    this.formPolygonStyle.fillOpacity = value;\n    this.applyPolygonStyle();\n  }\n\n\n  showSnackbar(message: string, type: 'success' | 'error') {\n    this.snackBar.open(message, 'Bezár', {\n      duration: 3000,\n      panelClass: type === 'success' ? ['snackbar-success'] : ['snackbar-error']\n    });\n  }\n\n}\n"
        }
    ]
}